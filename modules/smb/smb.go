package smb

import (
	"fmt"
	"net"
	"GoScan/modules/data"
	"GoScan/core/ProbeParser/Types"
	"encoding/binary"
)


var request1 = []byte{0x00,0x00,0x00,0x45,0xff,0x53,0x4d,0x42,0x72,0x00,0x00,0x00,0x00,0x18,0x53,0xc8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x22,0x00,0x02,0x4e,0x54,0x20,0x4c,0x4d,0x20,0x30,0x2e,0x31,0x32,0x00,0x02,0x53,0x4d,0x42,0x20,0x32,0x2e,0x30,0x30,0x32,0x00,0x02,0x53,0x4d,0x42,0x20,0x32,0x2e,0x3f,0x3f,0x3f,0x00} 
var request2 = []byte{0x00,0x00,0x00,0xe8,0xfe,0x53,0x4d,0x42,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x00,0x05,0x00,0x01,0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0xa7,0x22,0x57,0x31,0xd9,0x03,0xec,0x11,0x92,0x65,0x3c,0x58,0xc2,0x75,0xac,0xfa,0x70,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x02,0x10,0x02,0x00,0x03,0x02,0x03,0x11,0x03,0x00,0x00,0x01,0x00,0x26,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x20,0x00,0x01,0x00,0x06,0x41,0x15,0xa2,0x9b,0x6f,0x7a,0x8f,0xda,0xa7,0xe9,0xf3,0xed,0xa8,0x10,0x31,0x88,0x74,0x9e,0x53,0xaf,0xf7,0x92,0x36,0x38,0x8d,0x99,0xe6,0x0a,0x27,0x4b,0x84,0x00,0x00,0x02,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x02,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x02,0x00,0x03,0x00,0x01,0x00,0x05,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x31,0x00,0x39,0x00,0x32,0x00,0x2e,0x00,0x31,0x00,0x36,0x00,0x38,0x00,0x2e,0x00,0x36,0x00,0x2e,0x00,0x36,0x00,0x30,0x00} 
var request3 = []byte{0x00,0x00,0x00,0xa2,0xfe,0x53,0x4d,0x42,0x40,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x21,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x48,0x06,0x06,0x2b,0x06,0x01,0x05,0x05,0x02,0xa0,0x3e,0x30,0x3c,0xa0,0x0e,0x30,0x0c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a,0xa2,0x2a,0x04,0x28,0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,0x01,0x00,0x00,0x00,0x97,0x82,0x08,0xe2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x61,0x4a,0x00,0x00,0x00,0x0f} 

func Load() {
	data.PortModules[445] = append(data.PortModules[445], SmbModule)
}


func Check(err error) {
    if err != nil {
        fmt.Println(err)
    }
}

func ScanData(data []byte, search []byte) uint16 {
	ix := 0
	offset := uint16(0)		

	for _, b := range data {
		
		if search[ix] == b {
			ix++
		} else {
			ix = 0
		}
		offset++

		if ix == len(search) {
			return offset - uint16(len(search))				
		}
	}
	
	return offset - uint16(len(search))
}

func SmbModule(result *Types.Result) {

	reply := make([]byte, 2048)

	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", (*result).Target.IP, (*result).Target.Port ))
	if err != nil {
		fmt.Println(err)
		return
	}
	defer conn.Close()

	// sending the first request
	_, err = conn.Write(request1)
	Check(err)
	_, err = conn.Read(reply)

	// second request
	_, err = conn.Write(request2)
	Check(err)
	_, err = conn.Read(reply)

	// third request
	_, err = conn.Write(request3)
	Check(err)
	_, err = conn.Read(reply)


	// getting the SMB packet 
	reply = reply[4:]
		
	// extracting the NTLM Secure Service Provider offset (scanning for the right magic)
	ntlmProviderOffset := ScanData(reply, []byte{ 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50})
	
	// getting the length of the domain name of the computer (or the name of the computer if in WORKGROUP)
	domainNameLength := binary.LittleEndian.Uint16(reply[ntlmProviderOffset + 14: ntlmProviderOffset + 16])

	// getting the offset of the domain name 
	domainNameOffset := binary.LittleEndian.Uint16(reply[ntlmProviderOffset + 16: ntlmProviderOffset + 20])

	// extracting the domain name
	domainName := string(reply[ntlmProviderOffset + domainNameOffset: ntlmProviderOffset + domainNameOffset + domainNameLength])


	// getting offset of "Target Info" field in the NTLM Provider 
	targetInfoOffset := ntlmProviderOffset + domainNameOffset + domainNameLength

	// getting again the domain name length
	domainNameLength = binary.LittleEndian.Uint16(reply[targetInfoOffset + 2: targetInfoOffset + 4])

	// extracting hostname information
	hostnameOffset := targetInfoOffset + 4 + domainNameLength + 2
	hostnameLength := binary.LittleEndian.Uint16(reply[hostnameOffset: hostnameOffset + 2 ])	
	hostname := string(reply[hostnameOffset + 2: hostnameOffset + 2 + hostnameLength])
	
	// extracting the OS information
	versionOffset := ntlmProviderOffset + 48
	osMajor := reply[versionOffset]
	versionOffset += 1
	osMinor := reply[versionOffset]
	versionOffset += 1
	osBuild := binary.LittleEndian.Uint16(reply[versionOffset: versionOffset + 2])

	(*result).Hostname = hostname
	(*result).Version = fmt.Sprintf("%d.%d.%d", osMajor, osMinor, osBuild)
	(*result).Info = fmt.Sprintf("Domain Name: %s", domainName)
}